/*
 * main.c
 *
 *  Created on: 2024. 11. 30.
 *      Author: foodbug
 */

#include "xil_io.h"
#include "stdio.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xtmrctr.h"

#define GPIO_DEVICE_ID XPAR_AXI_GPIO_0_DEVICE_ID   // AXI GPIO Device ID
#define TIMER_DEVICE_ID XPAR_AXI_TIMER_0_DEVICE_ID // AXI Timer Device ID
#define GPIO_CHANNEL 1                             // GPIO 채널 번호
#define TIMER_COUNTER 0                            // 타이머 카운터 번호

XGpio Gpio;           // GPIO 인스턴스
XTmrCtr Timer;        // 타이머 인스턴스

// GPIO 초기화 함수
void init_gpio() {
    int Status;

    // GPIO 초기화
    Status = XGpio_Initialize(&Gpio, GPIO_DEVICE_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("GPIO Initialization Failed\n");
    }

    // GPIO를 입력 모드로 설정
    XGpio_SetDataDirection(&Gpio, GPIO_CHANNEL, 0xFFFFFFFF); // 모든 핀을 입력으로 설정
}

// 타이머 초기화 함수
void init_timer() {
    int Status;

    // 타이머 초기화
    Status = XTmrCtr_Initialize(&Timer, TIMER_DEVICE_ID);
    if (Status != XST_SUCCESS) {
        xil_printf("Timer Initialization Failed\n");
    }

    // 타이머 자동 재로드 비활성화 및 다운 카운트 설정
    XTmrCtr_SetOptions(&Timer, TIMER_COUNTER, XTC_AUTO_RELOAD_OPTION | XTC_DOWN_COUNT_OPTION);
}

// PWM 펄스 폭 측정 함수
int measure_pulse_width() {
    u32 pwm_state, start_time, end_time;

    // PWM 신호가 HIGH 상태가 될 때까지 대기
    do {
        pwm_state = XGpio_DiscreteRead(&Gpio, GPIO_CHANNEL) & 0x1;
    } while (pwm_state == 0);

    // HIGH 상태가 시작되면 타이머 시작
    XTmrCtr_Reset(&Timer, TIMER_COUNTER);
    XTmrCtr_Start(&Timer, TIMER_COUNTER);
    start_time = XTmrCtr_GetValue(&Timer, TIMER_COUNTER);

    // PWM 신호가 LOW 상태가 될 때까지 대기
    do {
        pwm_state = XGpio_DiscreteRead(&Gpio, GPIO_CHANNEL) & 0x1;
    } while (pwm_state == 1);

    // LOW 상태가 되면 타이머 정지
    end_time = XTmrCtr_GetValue(&Timer, TIMER_COUNTER);
    XTmrCtr_Stop(&Timer, TIMER_COUNTER);

    // 펄스 폭 계산
    return end_time - start_time; // 타이머 값은 클럭 사이클 단위
}

// 펄스 폭을 거리로 변환 함수
float pulse_width_to_distance(int pulse_width, float clock_period_ns) {
    // 펄스 폭(클럭 사이클)을 μs로 변환
    float pulse_width_us = pulse_width * clock_period_ns / 1000.0;

    // 거리 계산: 147μs = 1인치
    return pulse_width_us / 147.0;
}

int main() {
    xil_printf("Starting PWM Debugging\n");

    init_gpio();

    u32 pwm_state;

    while (1) {
        // GPIO에서 PWM 상태 읽기
        pwm_state = XGpio_DiscreteRead(&Gpio, GPIO_CHANNEL) & 0x1;

        // PWM 상태 출력
        xil_printf("PWM State: %u\n", pwm_state);

        // 간단한 딜레이
        for (volatile int i = 0; i < 100000; i++);
    }

    return 0;
}

